// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE

import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function parseHtml(idx, str) {
  var substr = $$String.sub(str, 0, idx);
  var exit = 0;
  var foundIdx;
  try {
    foundIdx = $$String.rindex(substr, /* "<" */60);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              substr,
              idx
            ];
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    if (foundIdx === (idx - 1 | 0)) {
      var exit$1 = 0;
      var closingBracketPos;
      try {
        closingBracketPos = $$String.index_from(str, foundIdx, /* ">" */62);
        exit$1 = 2;
      }
      catch (exn$1){
        return /* tuple */[
                substr,
                idx
              ];
      }
      if (exit$1 === 2) {
        var idx$prime = closingBracketPos + 1 | 0;
        var substr$prime = $$String.sub(str, 0, idx$prime);
        return /* tuple */[
                substr$prime,
                idx$prime
              ];
      }
      
    } else {
      return /* tuple */[
              substr,
              idx
            ];
    }
  }
  
}

function write_(idx, text, preserve, t) {
  var initialText = preserve ? t[/* el */2].innerHTML : "";
  return new Promise((function (resolve, param) {
                var writeRec = function (idx, text, t) {
                  return setTimeout((function (param) {
                                if (idx <= text.length) {
                                  var match = parseHtml(idx, text);
                                  t[/* el */2].innerHTML = initialText + match[0].replace("\n", "<br />");
                                  writeRec(match[1] + 1 | 0, text, t);
                                  return /* () */0;
                                } else {
                                  var match$1 = t[/* text */3];
                                  if (match$1) {
                                    return resolve(/* Text */[match$1[0]]);
                                  } else {
                                    console.log("empty array");
                                    return resolve(/* Done */1);
                                  }
                                }
                              }), t[/* timeout */1]);
                };
                writeRec(idx, text, t);
                return /* () */0;
              }));
}

function appendCursor(el) {
  var style = document.createElement("style");
  style.innerHTML = ".re-typed-text:after {\n    animation: re-typed-blinker 0.7s step-end infinite;\n    content: '|';\n    color: white;\n    font-weight: bold;\n   }\n\n  @keyframes re-typed-blinker {\n   50% {\n    opacity: 0;\n   }\n  }";
  var textNode = document.createElement("span");
  textNode.className = "re-typed-text";
  el.appendChild(textNode);
  el.appendChild(style);
  return textNode;
}

function make(el) {
  el.innerHTML = "";
  var textEl = appendCursor(el);
  return /* record */[
          /* timeoutId */undefined,
          /* timeout */40,
          /* el */textEl,
          /* text : [] */0,
          /* current */Promise.resolve(/* Init */0)
        ];
}

function write(text, $staropt$star, t) {
  var preserve = $staropt$star !== undefined ? $staropt$star : false;
  var t$prime_000 = /* timeoutId */t[/* timeoutId */0];
  var t$prime_001 = /* timeout */t[/* timeout */1];
  var t$prime_002 = /* el */t[/* el */2];
  var t$prime_003 = /* text : :: */[
    text,
    t[/* text */3]
  ];
  var t$prime_004 = /* current */t[/* current */4];
  var t$prime = /* record */[
    t$prime_000,
    t$prime_001,
    t$prime_002,
    t$prime_003,
    t$prime_004
  ];
  var current = t[/* current */4].then((function (o) {
          if (typeof o === "number") {
            if (o !== 0) {
              return Promise.resolve(/* Done */1);
            } else {
              return write_(0, text, preserve, t$prime);
            }
          } else {
            return write_(0, " " + text, preserve, t$prime);
          }
        }));
  return /* record */[
          t$prime_000,
          t$prime_001,
          t$prime_002,
          t$prime_003,
          /* current */current
        ];
}

function wait(ms, t) {
  var current = t[/* current */4].then((function (o) {
          var ms$1 = ms;
          var op = o;
          return new Promise((function (resolve, param) {
                        console.log("waiting...");
                        setTimeout((function (param) {
                                return resolve(op);
                              }), ms$1);
                        return /* () */0;
                      }));
        }));
  return /* record */[
          /* timeoutId */t[/* timeoutId */0],
          /* timeout */t[/* timeout */1],
          /* el */t[/* el */2],
          /* text */t[/* text */3],
          /* current */current
        ];
}

function waitForPromise(promise, t) {
  var current = t[/* current */4].then((function (param) {
            return promise;
          })).then((function (param) {
          return t[/* current */4];
        }));
  return /* record */[
          /* timeoutId */t[/* timeoutId */0],
          /* timeout */t[/* timeout */1],
          /* el */t[/* el */2],
          /* text */t[/* text */3],
          /* current */current
        ];
}

export {
  make ,
  wait ,
  waitForPromise ,
  write ,
  
}
/* No side effect */
